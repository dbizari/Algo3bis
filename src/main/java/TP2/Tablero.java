/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package TP2;

import Excepciones.*;

import java.util.*;

public class Tablero {

    private HashMap<Coordenada, Celda> tablero;
    private int filasTotales;
    private int columnasTotales;
    private int finSectorUno;

    public Tablero(int cantFilas, int cantCol) {

        tablero = new HashMap<Coordenada, Celda>();
        filasTotales = cantFilas;
        columnasTotales = cantCol;
        finSectorUno = (cantFilas/2);
        int sector;

        for(int i=0; i< cantFilas; i++){
            for(int j = 0; j < cantCol; j++) {
                Coordenada coordenada = new Coordenada(i,j);
                //ESTA BIEN ESTE IF??
                if(i < finSectorUno) {
                    sector = 1;
                } else {
                    sector = 2;
                }
                tablero.put(coordenada, new Celda(sector));
            }
        }
    }

    public int getCantFilas() {
        return filasTotales;
    }

    public int getCantColumnas() {
        return columnasTotales;
    }

    private Celda getCeldaPorCoordenada(Coordenada coordenada) throws CoordenadaFueraDeRango{
        Celda celda = tablero.get(coordenada);
        if (celda == null){
            throw new CoordenadaFueraDeRango();
        }
        return celda;
    }

    public Coordenada getCoordenada(int x, int y) throws CoordenadaFueraDeRango {
        Set<Coordenada> setCoordenadas = tablero.keySet();
        for (Coordenada coordenada : setCoordenadas) {
            if (x == coordenada.getCoordenadaX() && y == coordenada.getCoordenadaY()) {
                return coordenada;
            }
        }
        throw new CoordenadaFueraDeRango();
    }

    public Celda getCelda(int x, int y) throws CoordenadaFueraDeRango {
        //VER SI SE PUEDE CAMBIAR POR TABLERO.GET(COORDENADA), PASANDO COMO PARAMETRO LA COORDENADA.
        Set<Coordenada> setCoordenadas = tablero.keySet();
        for (Coordenada coordenada : setCoordenadas) {
            if (x == coordenada.getCoordenadaX() && y == coordenada.getCoordenadaY()) {
                return tablero.get(coordenada);
            }
        }
        throw new CoordenadaFueraDeRango();

    }

    public Coordenada getCoordenadasUnidadEn(int x, int y) throws CoordenadaFueraDeRango {
        Celda celda = getCelda(x, y);
        return celda.getUnidad().getCoordenadas();
    }

    public void colocarUnidad(Unidad unidad) throws CeldaDeTerritorioEnemigo, CeldaOcupada, CoordenadaFueraDeRango {
        Coordenada coordenadas = unidad.getCoordenadas();
        Jugador jugador = unidad.getDueño();
        coordenadas.coordenadaDentroDeTablero(filasTotales, 0, columnasTotales, 0);
        //coordenadas.enSectorAliado(jugador);
        int x = coordenadas.getCoordenadaX();
        int y = coordenadas.getCoordenadaY();
        Celda celda = getCelda(x, y);
        if(!celda.esDeSectorAliado(jugador)) {
            throw new CeldaDeTerritorioEnemigo();
        }
        celda.colocarUnidad(unidad);
    }

    public void atacarDesdeHasta(int desdeFil, int desdeCol, int hastaFil, int hastaCol) throws ErrorAutoAtaque, ErrorNoHayUnidadAtacante, CoordenadaFueraDeRango {

        Celda celdaAliada = getCelda(desdeFil, desdeCol);
        Celda celdaEnemiga = getCelda(hastaFil, hastaCol);
        List<Unidad> enemigosCercanos = this.ObtenerEnemigosCercanos(celdaAliada);
        List<Unidad> aliadosCercanos = this.ObtenerAliadosCercanos(celdaAliada);
        celdaAliada.atacar(celdaEnemiga, enemigosCercanos, aliadosCercanos);
    }

    public void moverUnidadDesdeHasta(int desdeFil, int desdeCol, int hastaFil, int hastaCol) throws CeldaOcupada, NoPuedeMoverseException, CoordenadaFueraDeRango {
        Celda celdaNueva = this.getCelda(hastaFil, hastaCol); //TODO esto no es solo una celda, deberia ser una agrupacion desde hasta.
        Celda celdaActual = this.getCelda(desdeFil, desdeCol);
        Agrupacion unaAgrupacion = celdaActual.getUnidad().getAgrupacion(); //Puede devolver Una agrupacion activa o inactiva
        this.enviarInvitacionAUnidadesContiguas(this.getCelda(desdeFil,desdeCol), unaAgrupacion);

        //Batallon unBatallon = new Batallon(); //TODO Encapsularlo en soldado con agrupaciones
        //TODO Pedir agrupacion a la unidad actual, enviar invite a todas, la agrupacion se encarga de ver si las agrega o no las agrega, siempre va a estar con una, despues hay que ver si alcanza ono. Agrupacion dame la lista de coordenadas para mover.
        //TODO todas se deben mover con el mismo metodo.

        /*
        this.getCelda(desdeFil,desdeCol).getUnidad().recibirInvitacionABatallon(unBatallon);
        if(unBatallon.sePudoUnir(this.getCelda(desdeFil,desdeCol).getUnidad())){
            this.enviarInvitacionAUnidadesContiguas(this.getCelda(desdeFil,desdeCol), unBatallon);
        }*/

        celdaNueva.colocarUnidad(celdaActual.getUnidad());
        celdaActual.vaciar();
        Coordenada coordenadaAMover = getCoordenada(hastaFil, hastaCol);
        celdaNueva.getUnidad().mover(coordenadaAMover);
    }
    /*
    public void buscarSoldadosContiguos(int x, int y,List<Celda> soldados){
        this.buscarSoldadosAdistancia1(x,y,soldados);
        if (soldados.size() >= 3) {
            while (soldados.size() > 3){
                soldados.remove(soldados.size() - 1);
            }
            return;
        }else {
            //TODO cada vez que entra en la recursividad esto arranca de 0 entonces siempre toma el primer nodo, pensar mejor el algoritmo!!!
            for (int i = 1; i < soldados.size(); i++) { //cambie i = 0 por 1
                buscarSoldadosContiguos(soldados.get(i).getUnidad().getCoordenadas().getCoordenadaX(),soldados.get(i).getUnidad().getCoordenadas().getCoordenadaY(),soldados);
                if(soldados.size() == 3)
                    break;
            }
        }
        return;
        //Buscar contiguos a distancia 1
        //Meterme recursivamente en uno y buscar contiguos si el largo de soldados no es mayor a 3
        // repetir para cada uno hasta llegar a 3
        // devolver
    }

    private void buscarSoldadosAdistancia1(int x, int y,List<Celda> soldDist1){
        try {
            int tempX = x+1;
            int tempY = y;
            //TODO el contains no esta funcionando
            if(this.getCelda(tempX,tempY).getUnidad() instanceof SoldadoInfanteria && !soldDist1.contains(this.getCelda(tempX,tempY))){
                soldDist1.add(this.getCelda(tempX,tempY));
            }
            tempX = x-1;
            tempY = y;
            if(this.getCelda(tempX,tempY).getUnidad() instanceof SoldadoInfanteria && !soldDist1.contains(this.getCelda(tempX,tempY))){
                soldDist1.add(this.getCelda(tempX,tempY));
            }
            tempX = x;
            tempY = y+1;
            if(this.getCelda(tempX,tempY).getUnidad() instanceof SoldadoInfanteria && !soldDist1.contains(this.getCelda(tempX,tempY))){
                soldDist1.add(this.getCelda(tempX,tempY));
            }
            tempX = x;
            tempY = y-1;
            if(this.getCelda(tempX,tempY).getUnidad() instanceof SoldadoInfanteria && !soldDist1.contains(this.getCelda(tempX,tempY))){
                soldDist1.add(this.getCelda(tempX,tempY));
            }
        }catch (Exception e){
            System.out.println(e.getMessage()); //TODO implementar un mejor manejo de errores
        }
        return;
    }*/

    public int verVida(int x, int y) throws CoordenadaFueraDeRango {
        Celda celda = getCelda(x, y);
        return celda.getUnidad().verVidaRestante();
    }

    public void curarDesdeHasta(int desdeFil, int desdeCol, int hastaFil, int hastaCol) throws NoPuedeCurar, ErrorAutoAtaque, ErrorNoHayUnidadAtacante, CoordenadaFueraDeRango {
        Celda celdaCuradora = getCelda(desdeFil, desdeCol);
        Celda celdaLastimada = getCelda(hastaFil, hastaCol);
        celdaCuradora.curar(celdaLastimada);
    }

    public List<Unidad> ObtenerEnemigosCercanos (Celda celdaPrincipal) {
        List<Unidad> EnemigosCercanos = new LinkedList<Unidad>();
        Unidad unidadPrincipal = celdaPrincipal.getUnidad();
        Jugador duenioPrincipal = unidadPrincipal.getDueño();

        Coordenada coordenadaPrincipal = celdaPrincipal.getUnidad().getCoordenadas();
        Set<Coordenada> setCoordenadas = tablero.keySet();
        for (Coordenada coordenada : setCoordenadas) {
            Celda celdaAux = tablero.get(coordenada);
            Unidad unidadAux = celdaAux.getUnidad();
            if (unidadAux!=null && unidadAux!=unidadPrincipal) {
                Jugador duenioAux = unidadAux.getDueño();
                if(duenioPrincipal!= duenioAux && coordenadaPrincipal.estanADistanciaCercana(unidadPrincipal, unidadAux)) {
                    EnemigosCercanos.add(unidadAux);
                }
            }

        }
        return EnemigosCercanos;
    }

    public List<Unidad> ObtenerAliadosCercanos (Celda celdaPrincipal) {
        List<Unidad> AliadosCercanos = new LinkedList<Unidad>();
        Unidad unidadPrincipal = celdaPrincipal.getUnidad();
        Jugador duenioPrincipal = unidadPrincipal.getDueño();

        Coordenada coordenadaPrincipal = celdaPrincipal.getUnidad().getCoordenadas();
        Set<Coordenada> setCoordenadas = tablero.keySet();
        for (Coordenada coordenada : setCoordenadas) {
            Celda celdaAux = tablero.get(coordenada);
            Unidad unidadAux = celdaAux.getUnidad();
            if (unidadAux!=null && unidadAux!=unidadPrincipal) {
                Jugador duenioAux = unidadAux.getDueño();
                if(duenioPrincipal== duenioAux && coordenadaPrincipal.estanADistanciaCercana(unidadPrincipal, unidadAux)) {
                    AliadosCercanos.add(unidadAux);
                }
            }

        }
        return AliadosCercanos;
    }


    public void enviarInvitacionAUnidadesContiguas(Celda celdaOrigen, Agrupacion unaAgrupacion) {
        Queue<Unidad> unidades = obtenerUnidadesADistancia1(celdaOrigen);
        List<Unidad> visitados = new ArrayList<Unidad>();
        Queue<Unidad> unidadesTemp;
        Unidad temp;
        Celda celdaTemp;

        while (!(unidades.isEmpty())){
            temp = unidades.remove();
            visitados.add(temp);
            temp.recibirInvitacionAAgrupacion(unaAgrupacion);
            try{
                celdaTemp = getCelda(temp.getCoordenadas().getCoordenadaX(),temp.getCoordenadas().getCoordenadaY());
            }catch (Exception e){
                System.out.println(e.getMessage()); //TODO implementar un mejor manejo de errores
                return;
            }
            unidadesTemp = obtenerUnidadesADistancia1(celdaTemp);
            for(Unidad uni : unidadesTemp){
                if(!visitados.contains(uni)){
                    unidades.add(uni);
                }
            }
        }
    }

    private Queue<Unidad> obtenerUnidadesADistancia1(Celda celdaOrigen){
        Queue<Unidad> contiguos = new LinkedList<>();
        List<Unidad> aliados = ObtenerAliadosCercanos(celdaOrigen);

        for(Unidad uni : aliados){
            if(celdaOrigen.esContiguaCon(uni))
                contiguos.add(uni);
        }
        return contiguos;
    }
}

